{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%load_ext autoreload\n",
    "from mps.state import *"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# TIME EVOLUTION"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# file: mps/evolution.py\n",
    "\n",
    "import numpy as np\n",
    "import scipy.linalg\n",
    "from mps.state import _truncate_vector"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Some of the commonly used operators:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# file: mps/evolution.py\n",
    "\n",
    "σz = np.diag([1.0,-1.0])\n",
    "i2 = np.identity(2)\n",
    "σx = np.array([[0, 1], [1, 0]])\n",
    "σy = -1j * σz @ σx\n",
    "\n",
    "def creation_op(d):\n",
    "    # Returns d dimensional cration operator\n",
    "    return np.diag(np.sqrt(np.arange(1,d)),-1).astype(complex)\n",
    "\n",
    "def annihilation_op(d):\n",
    "    # Returns d dimensional cration operator\n",
    "    return np.diag(np.sqrt(np.arange(1,d)),1).astype(complex)\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Nearest Neighbor Hamiltonians"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Below is the interface we use for nearest neighbor interaction Hamiltonians. It is initially empty."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# file: mps/evolution.py\n",
    "\n",
    "class NNHamiltonian(object):\n",
    "    \n",
    "    def __init__(self, size):\n",
    "        #\n",
    "        # Create a nearest-neighbor interaction Hamiltonian\n",
    "        # of a given size, initially empty.\n",
    "        #\n",
    "        self.size = size\n",
    "\n",
    "    def local_term(self, ndx, t=0.0):\n",
    "        #\n",
    "        # Return the local term acting on the ndx site.\n",
    "        #\n",
    "        return 0\n",
    "    \n",
    "    def interaction_term(self, ndx, t=0.0):\n",
    "        #\n",
    "        # Return the interaction between sites (ndx,ndx+1)\n",
    "        #\n",
    "        return 0"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "A particular case would be a translationally invariant, constant Hamiltonian\n",
    "$$H = \\sum_i \\left[O + \\sum_n L^{(n)} \\otimes R^{(n)}\\right]_\\text{site i}$$\n",
    "which has the same local term $O$ on all sites, and the same interaction given by the product of $L^{(n)}$ left and $R^{(n)}$ right operators."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# file: mps/evolution.py\n",
    "\n",
    "class TINNHamiltonian(NNHamiltonian):\n",
    "    \n",
    "    def __init__(self, local_term, intL, intR):\n",
    "        #\n",
    "        # Create a nearest-neighbor interaction Hamiltonian with fixed\n",
    "        # local terms and interactions.\n",
    "        #\n",
    "        #  - local_term: operator acting on every site\n",
    "        #  - int_left: list of L (applied to site ndx) operators\n",
    "        #  - int_right: list of R (applied to site ndx + 1) operators\n",
    "        #  - interaction: kronecker product of corresponding L and R pairs\n",
    "        #\n",
    "        self.local = local_term\n",
    "        self.int_left = intL\n",
    "        self.int_right = intR\n",
    "        self.interaction = np.array([np.kron(L,R) for L,R in zip(intL, intR)]).sum(axis = 0)\n",
    "\n",
    "    def local_term(self, ndx, t=0.0):\n",
    "        #\n",
    "        # Return the local term acting on the ndx site.\n",
    "        #\n",
    "        return self.local\n",
    "    \n",
    "    def interaction_term(self, ndx, t=0.0):\n",
    "        #\n",
    "        # Return the interaction between sites (ndx,ndx+1)\n",
    "        #\n",
    "        return self.interaction"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In increasing level of complexity, we can have different local terms and different interactions on every site\n",
    "$$H = \\sum_i \\left[O_i + \\sum_n L^{(n)}_i \\otimes R^{(n)}_i\\right]_\\text{site i}$$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# file: mps/evolution.py\n",
    "\n",
    "class ConstantNNHamiltonian(NNHamiltonian):\n",
    "    \n",
    "    def __init__(self, size):\n",
    "        #\n",
    "        # Create a nearest-neighbor interaction Hamiltonian with fixed\n",
    "        # local terms and interactions.\n",
    "        #\n",
    "        #  - local_term: operators acting on each site (can be different for each site)\n",
    "        #  - int_left, int_right: list of L and R operators (can be different for each site)\n",
    "        #\n",
    "        self.local_terms = [0] * size\n",
    "        self.int_left = [[]] * (size-1)\n",
    "        self.int_right = [[]] * (size-1)\n",
    "        self.interactions = [0] * (size-1)\n",
    "\n",
    "    def set_local_term(self, ndx, operator):\n",
    "        #\n",
    "        # Set the local term acting on the given site\n",
    "        #\n",
    "        self.local_terms[ndx] = operator\n",
    "\n",
    "    def add_interaction_term(self, ndx, L, R):\n",
    "        #\n",
    "        # Add an interaction term $L \\otimes R$ acting on site 'ndx'\n",
    "        #\n",
    "        # Add to int_left, int_right\n",
    "        #\n",
    "        # Update the self.interactions[ndx] term\n",
    "        self.int_left[ndx].append(L)\n",
    "        self.int_right[ndx].append(R)\n",
    "        self.interactions[ndx] += np.kron(L,R)\n",
    "\n",
    "    def local_term(self, ndx, t=0.0):\n",
    "        #\n",
    "        # Return the local term acting on the ndx site.\n",
    "        #\n",
    "        return self.local_terms[ndx]\n",
    "    \n",
    "    def interaction_term(self, ndx, t=0.0):\n",
    "        #\n",
    "        # Return the interaction between sites (ndx,ndx+1)\n",
    "        #\n",
    "        return self.interactions[ndx]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Suzuki-Trotter Decomposition"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In Suzuki-Trotter decomposition, the Hamiltonians of the nearest neighbor couplings can be decomposed into two non-commuting parts, $H_{\\text{odd}} $ and $ H_{\\text{even}} $, so that all additive 2-site operators in each part commute with each other.\n",
    "\n",
    "Let us consider a simple example of tight binding model with on-site potential and decompose the Hamiltonian into 2-site terms, so that $H=\\sum_i h_{i,i+1}$. \n",
    "\\begin{equation}\n",
    "h_{i,i+1} = \\left(\\frac{\\omega}{2}  a_i^\\dagger a_i \\right) + \\left(\\frac{\\omega}{2}  a_{i+1}^\\dagger a_{i+1} \\right) - \\left( t a_{i}^\\dagger a_{i+1} + \\text{h.c.} \\right).\n",
    "\\end{equation}\n",
    "Since $[h_{i,i+1},h_{i+2,i+3}] = 0$, we can group these terms for even and odd $i$, so that $H = H_{\\text{odd}} + H_{\\text{even}} $. \n",
    "\n",
    "Note that the local term $ a_i^\\dagger a_i$ appears only in one the groups for $i=1$ and $i=N$. Therefore we need to add two on-site terms $h_1 = \\left(\\frac{\\omega}{2}  a_1^\\dagger a_1 \\right) $ and $h_N = \\left(\\frac{\\omega}{2}  a_N^\\dagger a_N \\right) $, separately. So that $H_{\\text{even}} \\rightarrow H_{\\text{evem}} + h_1$, and $h_N$ is included similarly depending on whether $N$ is even or odd.\n",
    "\n",
    "And the evolution operator becomes\n",
    "$$e^{-i \\hat{H} \\Delta t} = e^{-i \\hat{H}_{\\text{odd}} \\Delta t}  e^{-i \\hat{H}_{\\text{even}} \\Delta t} + O(\\Delta t^2).$$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The class Trotter_unitaries creates a list of Trotter unitarities depending on evenodd value. \n",
    "\n",
    "If evenodd = 0:\n",
    "$$ U_{\\text{odds}} = [U_{1,2}, U_{3,4}, \\dots ], $$\n",
    "and if evenodd = 1:\n",
    "$$ U_{\\text{evens}} = [U_1, U_{2,3}, U_{4,5}, \\dots ], $$\n",
    "where $U_i = e^{-i h_{i} \\Delta t}$ and $U_{i,i+1} = e^{-i h_{i,i+1} \\Delta t}$. \n",
    "\n",
    "Note that the last element of  $U_{\\text{odds/evens}}$ is $U_N$ if $N$ is even/odd, and $U_{N-1,N}$ otherwise."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# file: mps/evolution.py\n",
    "\n",
    "class Trotter_unitaries(object):\n",
    "    \"\"\"\"Create Trotter unitarities from a nearest-neighbor interaction Hamiltonian.\n",
    "        \n",
    "    Attributes:\n",
    "    H = NNHamiltonian\n",
    "    δt = Time step\n",
    "    evenodd = 0, 1 depending on Trotter step\n",
    "    \"\"\"\n",
    "\n",
    "    def __init__(self, H, δt):\n",
    "        self.H = H\n",
    "        self.δt = δt\n",
    "        self.tensors = []\n",
    "        \n",
    "    def local_unitary(self, start):\n",
    "        \"\"\"Creates one-site exponentials from local H terms,\n",
    "        they are applied to first and last sites depending on evenodd value\"\"\"\n",
    "        Hloc = self.H.local_term(start)\n",
    "        U = scipy.linalg.expm(-1j * self.δt * 0.5 * Hloc)\n",
    "        return U\n",
    "        \n",
    "    def twosite_unitary(self, start):\n",
    "        \"\"\"Creates twp-site exponentials from interaction H terms\"\"\"\n",
    "        Hloc1 = self.H.local_term(start)\n",
    "        Hloc2 = self.H.local_term(start+1)\n",
    "        H12 = self.H.interaction_term(start) + \\\n",
    "              0.5 * (np.kron(Hloc1, np.eye(Hloc2.shape[0])) + \\\n",
    "                     np.kron(np.eye(Hloc1.shape[0]), Hloc2))\n",
    "        U = scipy.linalg.expm(-1j * self.δt * H12)\n",
    "        U = U.reshape(Hloc1.shape[0],Hloc2.shape[0],Hloc1.shape[0],Hloc2.shape[0])\n",
    "        return U\n",
    "    \n",
    "    \n",
    "\n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We apply each $U_{i,i+1} = e^{-i h_{i,i+1} \\Delta t}$ to two neighbouring tensors, $A_i$ and $A_{i+1}$ simultaneously as shown below."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<img src=\"fig_pdf/apply_mpo_to2site.svg\" style=\"max-width: 90%; width: 35em\">"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The resulting tensor $B$ is a two-site tensor. We split this tensor into two one-site tensors using left_orth_2site and right_orth_2site functions, which are defined in [this notebook](File%201c%20-%20Canonical%20form.ipynb). "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# file: mps/evolution.py\n",
    "\n",
    "def apply_1siteTrotter(U, ψ, start):\n",
    "    return np.einsum(\"ijk,mj -> imk \", ψ[start], U)\n",
    "\n",
    "def apply_2siteTrotter(U, ψ, start):\n",
    "    return np.einsum('ijk,klm,prjl -> iprm', ψ[start],\n",
    "                     ψ[start+1], U)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# file: mps/evolution.py\n",
    "\n",
    "def TEBD_sweep(H, ψ, δt, evenodd, tol=0):\n",
    "    #\n",
    "    # Apply a TEBD sweep by evolving with the pairwise Trotter Hamiltonian\n",
    "    # starting from left/rightmost site and moving on the 'direction' (>0 right,\n",
    "    # <0 left) by pairs of sites.\n",
    "    #\n",
    "    # - H: NNHamiltonian\n",
    "    # - ψ: Initial state in CanonicalMPS form (modified destructively)\n",
    "    # - δt: Time step\n",
    "    # - evenodd: 0, 1 depending on Trotter step\n",
    "    # - direction: where to move\n",
    "    #\n",
    "    Trotter = Trotter_unitaries(H, δt)\n",
    "    def update_local_site(start, dr):\n",
    "        # Apply local exponential and move\n",
    "        A = apply_1siteTrotter(Trotter.local_unitary(start) , ψ, start)\n",
    "        ψ.update_canonical(A, dr, tolerance=tol)\n",
    "        \n",
    "    def update_two_site(start, dr):\n",
    "        # Apply combined local and interaction exponential and move\n",
    "        AA = apply_2siteTrotter(Trotter.twosite_unitary(start) , ψ, start)\n",
    "        ψ.update_canonical_2site(AA, dr, tolerance=tol)\n",
    "\n",
    "\n",
    "    if ψ.center == 0:\n",
    "        # Move rightwards\n",
    "        dr = +1\n",
    "    else:\n",
    "        # Move leftwards\n",
    "        dr = -1\n",
    "    \n",
    "    #\n",
    "    # Loop over ψ, updating pairs of sites acting with the unitary operator\n",
    "    # made of the interaction and 0.5 times the local terms\n",
    "    #\n",
    "    if dr < 0:\n",
    "        j = ψ.size - 1\n",
    "        if j%2 == evenodd:\n",
    "            update_local_site(j, dr)\n",
    "            j -= 1\n",
    "        while j > 0:\n",
    "            update_two_site(j - 1, dr)\n",
    "            j -= 2\n",
    "        if j == 0:\n",
    "            update_local_site(j, dr)\n",
    "    else:\n",
    "        j = 0\n",
    "        if j != evenodd:\n",
    "            update_local_site(j, dr)\n",
    "            j += 1\n",
    "        while j < ψ.size - 1:\n",
    "            update_two_site(j, dr)\n",
    "            j += 2\n",
    "        if j == ψ.size - 1:\n",
    "            update_local_site(j, dr)            \n",
    "            \n",
    "    return ψ\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Error in Suzuki-Trotter decomposition"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In the first order Suzuki-Trotter decomposition, evolution operator becomes\n",
    "\\begin{equation}\n",
    "e^{-i \\hat{H} \\Delta t} = e^{-i \\hat{H}_{\\text{odd}} \\Delta t}  e^{-i \\hat{H}_{\\text{even}} \\Delta t} + O(\\Delta t^2).\n",
    "\\label{eq:sterror}\n",
    "\\end{equation}\n",
    "Note that after $T/\\Delta t$ time steps, the accumulated error is in the order of $\\Delta t$.\n",
    "Higher order Suzuki-Trotter decompositions can be used to reduce error.\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Tests"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# file: mps/test/test_TEBD.py\n",
    "import unittest\n",
    "import mps.state\n",
    "from mps.evolution import *\n",
    "from mps.test.tools import *\n",
    "\n",
    "\n",
    "\n",
    "class TestTEBD_sweep(unittest.TestCase):\n",
    "    \n",
    "    def test_orthonormalization(self):\n",
    "        #\n",
    "        # We verify that our two-site orthonormalization procedure, \n",
    "        # does not change the state\n",
    "        #\n",
    "        δt = 0.1\n",
    "        H = TINNHamiltonian(0*σx, σx, σx)\n",
    "        Trotter = Trotter_unitaries(H, δt)\n",
    "\n",
    "        def ok(Ψ):\n",
    "            for start in range(Ψ.size-1):            \n",
    "                AA = apply_2siteTrotter(Trotter.twosite_unitary(start) , \n",
    "                                                      Ψ, start)\n",
    "                A, AC = mps.state.left_orth_2site(AA, DEFAULT_TOLERANCE)\n",
    "                AA_orth = np.einsum(\"ijk,klm -> ijlm\", A, AC)\n",
    "                self.assertTrue(similar(AA,AA_orth))                \n",
    "            for start in range(Ψ.size-1):            \n",
    "                AA = apply_2siteTrotter(Trotter.twosite_unitary(start) , \n",
    "                                                      Ψ, start)\n",
    "                A, AC = mps.state.right_orth_2site(AA, DEFAULT_TOLERANCE)\n",
    "                AA_orth = np.einsum(\"ijk,klm -> ijlm\", AC, A)\n",
    "                self.assertTrue(similar(AA,AA_orth))\n",
    "            \n",
    "            \n",
    "        test_over_random_mps(ok)\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%autoreload\n",
    "suite1 = unittest.TestLoader().loadTestsFromNames(['__main__.TestTEBD_sweep'])\n",
    "unittest.TextTestRunner(verbosity=2).run(suite1);"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Tight Binding Model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def TB_hamiltonian(N, d, sigma, ω, tt):\n",
    "    t_list = [tt]*(N-1)\n",
    "    potential = [ω]*N \n",
    "\n",
    "    int_left = [tt * annihilation_op(d) , tt * creation_op(d)]\n",
    "    int_right = [creation_op(d), annihilation_op(d)]\n",
    "\n",
    "    hmps = ConstantNNHamiltonian(N)\n",
    "    for i in range(N-1):\n",
    "        hmps.set_local_term(i, potential[i] * creation_op(d)@annihilation_op(d))\n",
    "        [hmps.add_interaction_term(i, int_left[j], int_right[j]) for j in range(len(int_left))]\n",
    "\n",
    "    hmps.set_local_term(N-1, potential[-1] * creation_op(d)@annihilation_op(d))\n",
    "    \n",
    "    return hmps"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Test for Tight Binding Model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import mps.state\n",
    "import scipy.sparse as sp\n",
    "import numbers\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "d=2\n",
    "# number of sites\n",
    "N=20\n",
    "# on-site energy / cavity freq.\n",
    "ω = np.pi\n",
    "# hopping parameter t\n",
    "tt = ω / 10\n",
    "\n",
    "# time step\n",
    "Nit = 10\n",
    "dt = 1e-2\n",
    "Tf=dt*Nit\n",
    "\n",
    "sigma=1\n",
    "\n",
    "x0 = N//2\n",
    "w0 = N//5\n",
    "k0 = np.pi/2\n",
    "γ=0.5\n",
    "xx=np.arange(N)\n",
    "\n",
    "hmps = TB_hamiltonian(N, d, sigma, ω, tt)\n",
    "trotter = Trotter_unitaries(hmps, dt)\n",
    "state0 = gaussian(N, x0, w0, k0)\n",
    "\n",
    "state_can = CanonicalMPS(state0, 0, tolerance=1e-8)\n",
    "norms = []\n",
    "for i in range(Nit):\n",
    "    print(i)\n",
    "    state_can = TEBD_sweep(hmps, state_can, dt, 0, tol=1e-8)\n",
    "    state_can = TEBD_sweep(hmps, state_can, dt, 1, tol=1e-8)\n",
    "    norms.append(state_can.norm2())\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Comparison with exact evolution"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def prepare_gaussian(xx,x0,w0,k0):\n",
    "    state0 = np.exp(-(xx-x0)**2 / w0**2 + 1j * k0*xx)\n",
    "    return state0 / np.linalg.norm(state0)\n",
    "\n",
    "def evolve(x0, w0, k0, N, Tf, sigma, γ, ω, tt):\n",
    "    xx=np.arange(N)\n",
    "    state0=prepare_gaussian(xx,x0,w0,k0)\n",
    "\n",
    "    HM = sp.diags([[tt]*N, ω, [tt]*N],\n",
    "                  offsets=[-1,0,+1],\n",
    "                  shape=(N,N),\n",
    "                  dtype=np.complex128)\n",
    "    if isinstance(Tf, numbers.Number):\n",
    "        return sp.linalg.expm_multiply(-1j * Tf * HM, state0)\n",
    "    else:\n",
    "        return np.array([sp.linalg.expm_multiply(-1j * t * HM, state0)\n",
    "                         for t in np.array(Tf)])\n",
    "    \n",
    "state_exact = evolve(x0, w0, k0, N, np.linspace(0, Tf, 21), sigma, γ, ω, tt)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "Nit = 10\n",
    "Ntotal = 6\n",
    "error_list = []\n",
    "\n",
    "dt = 1e-2\n",
    "dt_list = dt * np.arange(1,30)\n",
    "Nit_list = [int(Ntotal//dt) for dt in dt_list] \n",
    "overlap_list=[]\n",
    "\n",
    "state0 = mps.state.gaussian(N, x0, w0, k0)\n",
    "\n",
    "state_vec = prepare_gaussian(xx,x0,w0,k0)\n",
    "for dt, Nit in zip(dt_list, Nit_list):\n",
    "    print(dt)\n",
    "    state_can = mps.state.CanonicalMPS(state0, 0, tolerance=1e-8)    \n",
    "    state_exact = evolve(x0, w0, k0, N, dt*Nit, sigma, γ, ω, tt)\n",
    "    for i in range(Nit):\n",
    "        state_can = TEBD_sweep(hmps, state_can, dt, 0, tol=1e-8)\n",
    "        state_can = TEBD_sweep(hmps, state_can, dt, 1, tol=1e-8)\n",
    "    \n",
    "    state_exact=state_exact/np.linalg.norm(state_exact)\n",
    "    exact_mps = mps.state.wavepacket(state_exact)\n",
    "    #state_can.__init__(normalize=True)\n",
    "    error_list.append(np.mean(abs(mps.state.MPS(state_can[:]).all_expectation1\\\n",
    "                                 (creation_op(d)@annihilation_op(d))\n",
    "                                 -np.abs(state_exact)**2)))\n",
    "    overlap_list.append(1-abs(expectation.scprod(exact_mps,state_can)))\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "state_can.center"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "plt.plot(dt_list, error_list, \".-\", linewidth=2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
